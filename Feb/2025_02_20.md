# 🎯 학습한 내용

## 모듈

> 재사용과 유지보수를 용이하게 하기 위해 코드를 분리해서 파일로 구분해둔 것

<br>

## 모듈 사용방법

### CommonJS
> 웹 애플리케이션이 점점 커지고 복잡해지면서, 전역 상태에서 모든 변수를 관리하는 방식은 **충돌, 유지보수 어려움, 성능 문제** 등을 초래했고, 백엔드(Node.JS)에서도 JavaScript가 쓰이기 시작하면서 **모듈 시스템**에 대한 고민이 생겨나게되어 **CommonJS**가 탄생


#### 특징
- require 함수를 사용하여 모듈을 불러옴
- module.exports또는 exports 객체를 사용하여 모듈을 내보냄
- **동기적으로 동작** (파일을 즉시 로드함)
- **브라우저 환경에서 직접 실행할 수 없음** (번들링 필요)
- 전체 모듈을 가져오거나 특정 부분만 가져오는 것이 가능

#### 장점
- Node.js에서 기본적으로 지원하여 설정이 필요 없음
- 오래된 패키지나 기존 코드와의 호환성이 좋음

#### 단점
- 동기적으로 동작하여 느리다.
- Tree Shaking을 지원하지 않음(사용 되지 않는 코드를 제거하는 행위)

<br>


### ESM(ESModules)
> Common.js의 모듈 시스템 방식을 **브라우저에서도 사용**할 수 있도록 하기 위해 탄생  


#### 특징
- import와 export 키워드를 사용
- **비동기적**으로 동작
- **브라우저에서 직접 실행 가능**

#### 장점
- 최신 JavaScript 표준을 따름
- 비동기적으로 동작하여 성능이 향상됨
- Tree Shaking을 지원하여 불필요한 코드 제거 가능
  
#### 단점
- 기존 Node.js 환경에서는 기본적으로 지원되지 않으며 설정이 필요함
- 일부 패키지는 여전히 CommonJS 방식으로 작성됨

<br><br>

---
## JavaScript 엔진
> 자바스크립트 코드를 실행하는 프로그램 또는 **인터프리터**

#### 인터프리터
> **코드 한줄씩** 순차적으로 실행하며, 프로그래밍 언어를 기계어로 통역해주는 프로그램
- #### 컴파일러
  > **전체 코드를 한 번에 변환** 후 실행


<br>

### JavaScript 엔진구조

| 구분  | 설명 |
|------|------|
| **스택 (Stack)** | - 함수 실행 컨텍스트를 저장하는 메모리 공간 <br>- **기본형** 데이터 저장 |
| **힙 (Heap)** | - 객체와 함수같은 **참조형 데이터**를 저장하는 메모리 공간  <br>- 크기가 동적으로 변할 수 있는 데이터 저장  <br>- 가비지 컬렉터(GC)가 관리 |

<br>

### V8 엔진
>  Google에서 만든 자바스크립트 엔진으로, 속도 향상을 위해 인터프리터를 사용하는 대신 **JIT 컴파일러**를 사용하여 더 효율적으로 기계어로 변환한다. (가장 대표적이고, 많이 사용된다.)

#### JIT 컴파일러
> **인터프리터와 컴파일러의 장점을 결합**한 방식으로, 프로그램을 실행하는 시점에 기계어로 번역하여 성능 개선

<br>

### Javascript 코드실행 방식(v8엔진 동작방식)

#### 1️⃣ 파싱  
   소스 코드를 토큰(Token)으로 분해한 후, `추상 구문 트리(AST)`로 변환
   
#### 2️⃣ 바이트코드 생성  
   `AST`를 기반으로 `Ignition(인터프리터)`가 바이트코드 생성
   
#### 3️⃣ 실행 및 최적화  
   바이트코드 실행하면서, **JIT 컴파일러**가 자주 실행되는 코드를 찾아 최적화
   
#### 4️⃣ 가비지 컬렉션  
   `V8엔진`이 자동으로 사용하지 않는 메모리를 해제하여 효율적인 메모리 관리 
   
   - ****`Mark-and-Sweep` 알고리즘 사용****   
     전역 객체에서 접근할 수 있는 모든 객체를 **사용 중**으로 마크하고, 객체가 다른 객체에 의해 참조되지 않으면 **사용되지 않음**으로 판단하여 메모리에서 해제하여 공간을 확보하는 알고리즘

<br><br>

---
## 리플로우와 리페인트
> 브라우저가 화면을 다시 렌더링하는 과정으로 **요소가 시각적으로 변경되었을 때, 변화를 계산하여 화면에 그려주는 작업**

### 리플로우
> 브라우저가 `DOM 구조`를 다시 계산하여 각 요소의 위치와 크기를 재배치하는 과정

- `HTML`요소의 레이아웃이 변경될 때마다 발생
- `DOM` 구조 자체를 다시 계산
- 연산 비용이 높다
- 전체 문서 또는 특정 요소가 바뀐다

<br>

### 리페인트
> 브라우저의 **시각적 스타일**(색상, 배경, 그림자 등)이 변경될 때 발생하는 과정

- 레이아웃에는 변화가 없고, 색상, 배경, 그림자, 테두리 등의 스타일 만 변경
- `DOM` 변경 없음
- 연산 비용이 적다
- 특정 요소만 바뀐다

<br>

## Reflow, Repaint 최소화방법

- 최대한 `DOM 구조` 상 말단 노드에만 클래스를 사용(`DOM` 변경 최소화)

- 인라인 스타일 자제
  
- CSS에서의 JS 표현식 자제
  
- `position: relative` 사용 주의
  
- 대신, `position: absolute` 또는 `fixed` 사용하기






